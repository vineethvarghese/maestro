//   Copyright 2014 Commonwealth Bank of Australia
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

package au.com.cba.omnia.maestro.macros

import scala.reflect.macros.Context

import com.twitter.scrooge.ThriftStruct

import au.com.cba.omnia.humbug.HumbugThriftStruct

import au.com.cba.omnia.maestro.core.codec.Decode

/**
  * Creates a custom Decode for the given thrift struct where the scala code is generated by Humbug.
  * 
  * The Decode will look like this:
  * {{{
  * Decode((none, source, position) => {
  *   if (source.length < 7)
  *     DecodeError(source, position, NotEnoughInput(7, "au.com.cba.omnia.maestro.test.thrift.humbug.Types"))
  *   else
  *     {
  *       val fields = source.take(7).toArray
  *       var index = -1
  *       var tag = ""
  *       try {
  *         val struct = new Types()
  *         struct._1 = fields(0)
  *         {
  *           tag = "Boolean"
  *           index = 1
  *           struct._2 = fields(index).toBoolean
  *         }
  *         {
  *           tag = "Int"
  *           index = 2
  *           struct._3 = fields(index).toInt
  *         }
  *         {
  *           tag = "Long"
  *           index = 3
  *           struct._4 = fields(index).toLong
  *         }
  *         {
  *           tag = "Double"
  *           index = 4
  *           struct._5 = fields(index).toDouble
  *         }
  *         {
  *           tag = "Option[Int]"
  *           index = 5
  *           struct._6 = if (fields(index).isEmpty || fields(index) == none)
  *             Option.empty[Int]
  *           else
  *             Option(fields(index).toInt)
  *         }
  *         struct._7 = if (fields(6) == none)
  *           Option.empty[String]
  *         else
  *           Option(fields(6))
  *         DecodeOk(scala.Tuple3(source.drop(7), position + 7, struct))
  *       } catch {
  *         case NonFatal((e @ _)) => DecodeError(source.drop(index - position), position + index, ParseError(fields(index), tag, That(e)))
  *       }
  *     }
  * })
  * }}}
  */
object HumbugDecodeMacro {
  def impl[A <: ThriftStruct: c.WeakTypeTag](c: Context): c.Expr[Decode[A]] = {
    import c.universe._

    val stringType = weakTypeOf[String]

    val typ       = weakTypeOf[A]
    val typeName  = typ.toString
    val companion = typ.typeSymbol.companionSymbol
    val members   = Inspect.indexed[A](c)
    val size      = members.length
    val termName  = newTermName(typeName)

    def decodeUnknownSource(xs: List[(MethodSymbol, Int)]) = q"""
      if (source.length < $size) {
        DecodeError(source, position, NotEnoughInput($size, $typeName))
      } else {
        val fields = source.take($size).toArray
        var index  = -1
        var tag    = "" 
        try {
          val struct = new $typ()
          ..${decodeUnknowns(xs)}
          DecodeOk((source.drop($size), position + $size, struct))
        } catch {
          case NonFatal(e) => DecodeError(
            source.drop(index - position),
            position + index,
            ParseError(fields(index), tag, That(e))
          )
        }
      }
    """
    def decodeUnknowns(xs: List[(MethodSymbol, Int)]): List[Tree] = xs.map { case (x, i) =>
      val index  = i - 1
      val setter = newTermName("_" + i)

      MacroUtils.optional(c)(x.returnType).map { param =>
        if (param == stringType)
          q"""
            struct.$setter = 
              if (fields($index) == none) Option.empty[String]
              else                        Option(fields($index))
          """
        else {
          val method = newTermName("to" + param)
          val tag    = s"Option[$param]"
          q"""{
            tag   = $tag
            index = $index

            struct.$setter = 
            if (fields(index).isEmpty || fields(index) == none)
              Option.empty[$param]
            else
              Option(fields(index).$method)
          }"""
        }
      } getOrElse {
        if (x.returnType == stringType)
          q"struct.$setter = fields($index)"
        else {
          val method = newTermName("to" + x.returnType)
          val tag    = x.returnType.toString

          q"""{
            tag   = $tag
            index = $index
            struct.$setter = fields(index).$method
          }"""
        }
      }
    }

    val combined = q"""
      import au.com.cba.omnia.maestro.core.codec.Decode
      Decode((none, source, position) => {
        import scala.util.control.NonFatal
        import scalaz.\&/.That
        import au.com.cba.omnia.maestro.core.codec.{DecodeOk, DecodeError, DecodeResult, ParseError, NotEnoughInput, Decode}
  
        ${decodeUnknownSource(members)}
      })
    """

    c.Expr[Decode[A]](combined)
  }
}
